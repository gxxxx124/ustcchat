# 对话流程详解

## 📚 整体架构

系统使用 **LangGraph** 构建对话流程，采用**状态图（State Graph）**管理对话状态和工具调用。

### 核心组件

```
用户提问
    ↓
call_model（模型节点）
    ↓
should_continue（决策节点）
    ↓
    ├─→ tools（工具节点）→ call_model（循环）
    └─→ END（结束）
```

---

## 🔄 完整对话流程

### 流程图

```
┌─────────────┐
│  用户提问    │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│  call_model     │  ← 模型思考节点
│  (模型决策)      │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ should_continue │  ← 决策节点
│  (判断下一步)    │
└──────┬──────────┘
       │
       ├─ 有工具调用？
       │     │
       │     ▼
       │  ┌─────────────┐
       │  │   tools     │  ← 工具执行节点
       │  │ (执行工具)   │
       │  └──────┬──────┘
       │         │
       │         ▼
       │  ┌─────────────┐
       │  │ call_model  │  ← 再次调用模型
       │  │ (生成回答)  │
       │  └──────┬──────┘
       │         │
       │         ▼
       │  ┌─────────────┐
       │  │should_continue│
       │  └──────┬──────┘
       │         │
       └─────────┘
            │
            ▼
       ┌─────────┐
       │   END   │  ← 结束，返回最终答案
       └─────────┘
```

---

## 📝 详细步骤说明

### 步骤1：用户提问

```python
# 用户发送请求
POST /agent/chat
{
    "message": "差旅费标准是什么？",
    "knowledge_base_name": "nsrl_tech_docs",
    "session_id": "user_123_default"
}
```

**处理**：
- 创建或获取会话状态
- 将用户问题转换为 `HumanMessage`
- 初始化 AgentState

---

### 步骤2：call_model（模型思考节点）

#### 功能
模型分析用户问题，决定是否需要调用工具。

#### 执行流程

```python
async def call_model(state: AgentState):
    # 1. 获取消息历史
    messages = state["messages"]
    
    # 2. 构建系统提示
    system_prompt = """
    你是NSRL智能助手...
    可用工具：
    1. rag_knowledge_search: 查询知识库
    工作流程：
    1. 对于所有NSRL相关问题，必须首先使用 rag_knowledge_search
    2. 检查返回结果的最高相似度
    3. 基于知识库内容回答
    """
    
    # 3. 检查是否有工具调用结果
    has_tool_result = any(isinstance(msg, ToolMessage) for msg in messages)
    
    # 4. 绑定工具（如果没有工具结果）
    if has_tool_result:
        model_with_tools = model  # 不绑定工具，强制生成回答
    else:
        model_with_tools = model.bind_tools(available_tools)  # 绑定工具
    
    # 5. 调用模型
    response = await model_with_tools.ainvoke(messages)
    
    # 6. 返回响应
    return {"messages": [response]}
```

#### 模型决策

**情况1：需要调用工具**
```python
response = AIMessage(
    content="",  # 空内容
    tool_calls=[
        {
            "name": "rag_knowledge_search",
            "args": {"query": "差旅费标准"}
        }
    ]
)
```

**情况2：直接回答**
```python
response = AIMessage(
    content="根据知识库，差旅费标准是...",
    tool_calls=[]  # 无工具调用
)
```

---

### 步骤3：should_continue（决策节点）

#### 功能
判断下一步操作：调用工具 or 结束对话

#### 决策逻辑

```python
def should_continue(state: AgentState):
    messages = state["messages"]
    last_message = messages[-1]
    tool_call_count = state.get("tool_call_count", 0)
    
    # 1. 检查工具调用次数限制
    if tool_call_count >= 5:
        return END  # 超过5次，强制结束
    
    # 2. 检查是否有工具调用
    has_tool_calls = hasattr(last_message, "tool_calls") and last_message.tool_calls
    
    # 3. 检查是否有工具结果
    has_tool_result = any(isinstance(msg, ToolMessage) for msg in messages)
    
    # 4. 如果已有工具结果但模型又调用工具，强制结束
    if has_tool_result and has_tool_calls:
        return END
    
    # 5. 如果有工具调用，执行工具
    if has_tool_calls:
        return "tools"
    
    # 6. 否则结束
    return END
```

#### 决策结果

| 情况 | 返回 | 说明 |
|------|------|------|
| 有工具调用 | `"tools"` | 执行工具节点 |
| 无工具调用 | `END` | 结束对话，返回答案 |
| 工具调用次数≥5 | `END` | 强制结束 |
| 已有工具结果但又调用工具 | `END` | 强制结束，避免循环 |

---

### 步骤4：tools（工具执行节点）

#### 功能
执行模型请求的工具调用

#### 执行流程

```python
def tool_node(state: AgentState):
    messages = state["messages"]
    last_message = messages[-1]
    
    # 1. 获取工具列表
    tools = {
        "rag_knowledge_search": rag_tool,
        # ... 其他工具
    }
    
    # 2. 执行所有工具调用
    tool_messages = []
    for tool_call in last_message.tool_calls:
        tool_name = tool_call["name"]
        tool_args = tool_call["args"]
        
        # 3. 调用工具
        tool = tools[tool_name]
        response = tool.invoke(tool_args)
        
        # 4. 创建工具消息
        tool_message = ToolMessage(
            content=str(response),
            tool_call_id=tool_call["id"]
        )
        tool_messages.append(tool_message)
    
    # 5. 更新工具调用计数
    tool_call_count = state.get("tool_call_count", 0) + 1
    
    # 6. 返回工具结果
    return {
        "messages": tool_messages,
        "tool_call_count": tool_call_count
    }
```

#### 工具执行示例

**RAG工具调用**：
```python
# 模型请求
tool_call = {
    "name": "rag_knowledge_search",
    "args": {"query": "差旅费标准"}
}

# 工具执行
response = rag_tool.invoke({"query": "差旅费标准"})

# 返回结果
"""
📚 在知识库中找到 3 个相关文档片段：

【文档片段 - 结果 #1 (相似度: 0.8567)】
标题: 差旅费管理办法
内容: 根据《中国科学技术大学差旅费管理办法》...
来源: 差旅费管理办法.md
----------------------------------------
...
"""
```

---

### 步骤5：再次调用模型（生成最终回答）

#### 流程

```
工具结果 → call_model → 模型生成最终回答
```

#### 关键机制

**强制生成回答**：
```python
# 如果已有工具结果，添加系统提示
if has_tool_result:
    messages.append(SystemMessage(
        content="✅ 工具已返回相关结果（相似度: 0.8567）。"
                "请基于工具返回的知识库内容立即生成最终回答，不要再调用工具。"
    ))
    
    # 不绑定工具，强制模型生成回答
    model_with_tools = model  # 不绑定工具
```

**相似度检查**：
```python
# 提取工具返回的最高相似度
highest_similarity = extract_highest_similarity(tool_message.content)

if highest_similarity >= 0.3:
    # 相似度足够，基于结果生成回答
    messages.append(SystemMessage(
        content="✅ 工具已返回相关结果，请基于此生成回答"
    ))
else:
    # 相似度较低，告知用户
    messages.append(SystemMessage(
        content="⚠️ 工具返回结果相似度较低，请告知用户知识库中没有相关信息"
    ))
```

---

## 🔄 完整对话示例

### 示例：用户提问"差旅费标准是什么？"

#### 第1轮：模型决定调用工具

```
用户: "差旅费标准是什么？"
    ↓
call_model:
  - 分析问题：需要查询知识库
  - 决定：调用 rag_knowledge_search
  - 返回：AIMessage(tool_calls=[...])
    ↓
should_continue:
  - 检测到工具调用
  - 返回："tools"
    ↓
tools:
  - 执行：rag_knowledge_search({"query": "差旅费标准"})
  - 返回：ToolMessage(content="📚 在知识库中找到...")
```

#### 第2轮：模型生成最终回答

```
工具结果: ToolMessage(content="...相似度: 0.8567...")
    ↓
call_model:
  - 检查：已有工具结果
  - 添加系统提示："基于工具结果生成最终回答"
  - 不绑定工具（强制生成回答）
  - 返回：AIMessage(content="根据知识库，差旅费标准是...")
    ↓
should_continue:
  - 检测：无工具调用
  - 返回：END
    ↓
返回最终答案给用户
```

---

## 🎯 关键机制

### 1. 工具调用限制

```python
# 最多调用5次工具
if tool_call_count >= 5:
    return END
```

**目的**：防止无限循环，确保对话能够结束

### 2. 强制生成回答

```python
# 如果已有工具结果，强制模型生成最终回答
if has_tool_result:
    model_with_tools = model  # 不绑定工具
    messages.append(SystemMessage(
        content="请基于工具结果生成最终回答，不要再调用工具"
    ))
```

**目的**：确保模型基于工具结果生成回答，而不是继续调用工具

### 3. 相似度检查

```python
# 检查工具返回的相似度
highest_similarity = extract_highest_similarity(tool_message.content)

if highest_similarity >= 0.3:
    # 相似度足够，基于结果回答
else:
    # 相似度较低，告知用户没有相关信息
```

**目的**：确保只基于相关结果生成回答，避免基于不相关信息

### 4. 会话状态管理

```python
class AgentState(TypedDict):
    messages: Annotated[list, add]  # 消息历史（自动累加）
    tool_call_count: int            # 工具调用次数
    knowledge_base_name: str         # 知识库名称
    user_document_tools: List[str]   # 用户文档工具列表
    web_search_enabled: bool         # 网络搜索开关
```

**目的**：管理对话状态，支持多轮对话

---

## 📊 状态流转图

```
初始状态
    ↓
[HumanMessage: "差旅费标准是什么？"]
    ↓
call_model
    ↓
[AIMessage: tool_calls=[rag_knowledge_search]]
    ↓
should_continue → "tools"
    ↓
tools
    ↓
[ToolMessage: "📚 在知识库中找到..."]
    ↓
call_model
    ↓
[AIMessage: content="根据知识库，差旅费标准是..."]
    ↓
should_continue → END
    ↓
返回最终答案
```

---

## 🔧 工具调用详解

### RAG工具（rag_knowledge_search）

#### 工具定义
```python
Tool(
    name="rag_knowledge_search",
    description="使用RAG系统搜索知识库中的相关信息",
    func=rag_search_tool,
    args_schema=RAGSearchInput  # {"query": str}
)
```

#### 执行流程
```
1. 接收查询："差旅费标准"
    ↓
2. 向量化查询
    ↓
3. 在Qdrant中检索
    ↓
4. 加权混合搜索（标题+内容）
    ↓
5. 返回格式化结果
```

#### 返回格式
```
📚 在知识库中找到 3 个相关文档片段：

【文档片段 - 结果 #1 (相似度: 0.8567)】
标题: 差旅费管理办法
内容: 根据《中国科学技术大学差旅费管理办法》...
来源: 差旅费管理办法.md
----------------------------------------
...
```

---

## 💡 优化机制

### 1. 消息历史截断

```python
# 限制消息历史长度，防止显存溢出
if len(messages) > 25:
    messages = messages[-20:]  # 保留最新20条
```

### 2. 工具调用次数限制

```python
# 最多调用5次工具
if tool_call_count >= 5:
    return END
```

### 3. 智能决策

```python
# 如果已有工具结果但模型又调用工具，强制结束
if has_tool_result and has_tool_calls:
    return END
```

### 4. 相似度阈值

```python
# 只基于相似度≥0.3的结果生成回答
if highest_similarity >= 0.3:
    # 基于结果回答
else:
    # 告知用户没有相关信息
```

---

## 📝 在PPT中的表述建议

### 简洁版
> "对话流程采用LangGraph状态图管理，用户提问后，模型首先决定是否需要调用工具，如果需要则执行RAG检索，然后基于检索结果生成最终回答。"

### 技术版
> "系统使用LangGraph构建对话流程，包含三个核心节点：
> 1. **call_model**：模型分析问题，决定是否调用工具
> 2. **should_continue**：决策下一步操作（调用工具 or 结束）
> 3. **tools**：执行工具调用（如RAG检索）
> 
> 流程支持多轮工具调用，最多5次，确保对话能够正常结束。"

### 详细版
> "对话流程采用LangGraph状态图架构：
> 
> **第1轮**：用户提问 → 模型分析 → 决定调用RAG工具 → 执行工具 → 获取知识库结果
> 
> **第2轮**：工具结果 → 模型分析 → 基于结果生成最终回答 → 结束对话
> 
> **关键机制**：
> - 工具调用次数限制（最多5次）
> - 强制生成回答（已有工具结果时不再调用工具）
> - 相似度检查（只基于相关结果回答）
> - 会话状态管理（支持多轮对话）
> 
> 确保对话流程可控、高效、准确。"

---

## ✅ 总结

**对话流程的核心特点**：

1. ✅ **状态图管理**：使用LangGraph管理对话状态
2. ✅ **智能决策**：模型自主决定是否调用工具
3. ✅ **工具集成**：无缝集成RAG检索等工具
4. ✅ **流程控制**：防止无限循环，确保对话结束
5. ✅ **质量保证**：相似度检查，确保回答准确性

这是一个**企业级**的对话系统架构！

